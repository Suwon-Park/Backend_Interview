## 가바지 컬렉션(Garbage Collection)
C언어나 C++ 같은 언어에서 메모리 관리는 프로그래머의 책임임
필요한 메모리 공간을 라이브러리를 통해 운영체로 부터 할당받아 사용하다가 다 쓰면 다시 해제해서 운영체제로 반환해야 함
개발자가 꼼꼼히 메모리 관리를 하지 않는다면 운영체제로부터 메모리 공간을 할당받기만 하고 반환하지 않아 프로세스가 점점 커지다가 운영체제에 의해 시그널을 맞고 죽게 됨
메모리를 해제하지 않아서 생기는 이런 버그를 메모리 릭(Memory Leak)이라고 함

자바는 메모리 관리라는 막중한 책임에서 프로그래머를 자유롭게 해줬다
자바 프로그래머는 직접 메모리 공간의 할당과 반환을 수행하는 대신 JVM을 통해 메모리를 할당받는다
더 이상 사용되지 않는 메모리 공간은 JVM이 알아서 회수한 다음에 해제해줌
JVM의 이런 메모리 해제 동작을 가비지 컬렉션이라고 함

## 가비지(Garbage)
가비지 컬렉션은 더 이상 사용되지 않는 메모리 공간을 JVM이 알아서 회수해주는 동작을 의미한다고 함
더 이상 사용되지 않는 메모리 공간이 바로 가비지(Garbage)라고 할 수 있음
그렇다면 사용되지 않는 메모리 공간이란 어떤 것을 의미할까?
```
Person person = new Person("Dave");
person.sayHello();

person = person("Eric");
person.sayHello();
```
Dava 객체는 어떠한 경로로도 참조되지 않기 때문에 Unreachable 상태라고 하며,
이 객체는 가비지로 판단되어 회수 당하게 됨
가바지 컬렉션을 수행하는 가비지 컬렉터는 스택 변수로 부터 참조 체인을 통해 도달할 수 없는 객체들을 가비지로 판단하고, 이 객체들의 메모리 공간을 회수함

## stop-the-world
GC를 실행하기 위해 JVM이 애플리케이션 실행을 멈추는 것
stop-the-world가 발생하면 GC를 실행하는 쓰레드를 제외한 나머지 쓰레드는 모두 작업을 멈춤
GC 작업을 완료한 이후에야 중단했던 작업을 다시 시작함
어떤 알고리즘을 사용하더라도 stop-the-world는 발생
stop-the-world 시간을 어느 정도로 허용할 것인지는 실행할 애플리케이션의 특성에 따라 다름
(-> 새벽에 실행되는 배치 작업은 몇 초간 멈추는 것도 ok 하지만 리그오브레전드에서 랭킹 게임을 하고 있는데 갑자기 가비지 컬렉션을 한다고 몇 초간 동작이 멈춰버리면 매우 곤란)
대부분 JVM에서 GC 튜닝이라고 하면 stop-the-world 시간을 줄이는 것을 의미함

## Weak Generational Hypothesis
JVM의 가비지 컬렉터는 Weak Generational Hypothesis를 전제로 설계되어 있음
- 대부분의 객체들은 생성된 이후 짧은 시간안에 Unreachable 상태가 됨
- 생성된지 오래된 객체에서 방금 생성된 객체로의 참조는 아주 적음

여기서 우선 고려해봐야 할 점은 대부분의 객체들이 생성된 이후 짧은 시간안에 Unreachable 상태가 된다는 점


